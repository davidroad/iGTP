{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bda9a47c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import scanpy as sc\n",
    "from random import shuffle\n",
    "sc.settings.verbosity = 0\n",
    "from tqdm import tqdm\n",
    "import requests\n",
    "import os, sys\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "from .pert_util.py import parse_single_pert, parse_combo_pert, parse_any_pert, print_sys\n",
    "\n",
    "def rank_genes_groups_by_cov(\n",
    "    adata,\n",
    "    groupby,\n",
    "    control_group,\n",
    "    covariate,\n",
    "    pool_doses=False,\n",
    "    n_genes=50,\n",
    "    rankby_abs=True,\n",
    "    key_added='rank_genes_groups_cov',\n",
    "    return_dict=False,\n",
    "):\n",
    "\n",
    "    gene_dict = {}\n",
    "    cov_categories = adata.obs[covariate].unique()\n",
    "    for cov_cat in cov_categories:\n",
    "        #name of the control group in the groupby obs column\n",
    "        control_group_cov = '_'.join([cov_cat, control_group])\n",
    "\n",
    "        #subset adata to cells belonging to a covariate category\n",
    "        adata_cov = adata[adata.obs[covariate]==cov_cat]\n",
    "\n",
    "        #compute DEGs\n",
    "        sc.tl.rank_genes_groups(\n",
    "            adata_cov,\n",
    "            groupby=groupby,\n",
    "            reference=control_group_cov,\n",
    "            rankby_abs=rankby_abs,\n",
    "            n_genes=n_genes,\n",
    "            use_raw=False\n",
    "        )\n",
    "\n",
    "        #add entries to dictionary of gene sets\n",
    "        de_genes = pd.DataFrame(adata_cov.uns['rank_genes_groups']['names'])\n",
    "        for group in de_genes:\n",
    "            gene_dict[group] = de_genes[group].tolist()\n",
    "\n",
    "    adata.uns[key_added] = gene_dict\n",
    "\n",
    "    if return_dict:\n",
    "        return gene_dict\n",
    "\n",
    "    \n",
    "def get_DE_genes(adata, skip_calc_de):\n",
    "    adata.obs.loc[:, 'dose_val'] = adata.obs.condition.apply(lambda x: '1+1' if len(x.split('+')) == 2 else '1')\n",
    "    adata.obs.loc[:, 'control'] = adata.obs.condition.apply(lambda x: 0 if len(x.split('+')) == 2 else 1)\n",
    "    adata.obs.loc[:, 'condition_name'] =  adata.obs.apply(lambda x: '_'.join([x.cell_type, x.condition, x.dose_val]), axis = 1) \n",
    "    \n",
    "    adata.obs = adata.obs.astype('category')\n",
    "    if not skip_calc_de:\n",
    "        rank_genes_groups_by_cov(adata, \n",
    "                         groupby='condition_name', \n",
    "                         covariate='cell_type', \n",
    "                         control_group='ctrl_1', \n",
    "                         n_genes=len(adata.var),\n",
    "                         key_added = 'rank_genes_groups_cov_all')\n",
    "    return adata\n",
    "\n",
    "def get_dropout_non_zero_genes(adata):\n",
    "    \n",
    "    # calculate mean expression for each condition\n",
    "    unique_conditions = adata.obs.condition.unique()\n",
    "    conditions2index = {}\n",
    "    for i in unique_conditions:\n",
    "        conditions2index[i] = np.where(adata.obs.condition == i)[0]\n",
    "\n",
    "    condition2mean_expression = {}\n",
    "    for i, j in conditions2index.items():\n",
    "        condition2mean_expression[i] = np.mean(adata.X[j], axis = 0)\n",
    "    pert_list = np.array(list(condition2mean_expression.keys()))\n",
    "    mean_expression = np.array(list(condition2mean_expression.values())).reshape(len(adata.obs.condition.unique()), adata.X.toarray().shape[1])\n",
    "    ctrl = mean_expression[np.where(pert_list == 'ctrl')[0]]\n",
    "    \n",
    "    ## in silico modeling and upperbounding\n",
    "    pert2pert_full_id = dict(adata.obs[['condition', 'condition_name']].values)\n",
    "    pert_full_id2pert = dict(adata.obs[['condition_name', 'condition']].values)\n",
    "\n",
    "    gene_id2idx = dict(zip(adata.var.index.values, range(len(adata.var))))\n",
    "    gene_idx2id = dict(zip(range(len(adata.var)), adata.var.index.values))\n",
    "\n",
    "    non_zeros_gene_idx = {}\n",
    "    top_non_dropout_de_20 = {}\n",
    "    top_non_zero_de_20 = {}\n",
    "    non_dropout_gene_idx = {}\n",
    "\n",
    "    for pert in adata.uns['rank_genes_groups_cov_all'].keys():\n",
    "        p = pert_full_id2pert[pert]\n",
    "        X = np.mean(adata[adata.obs.condition == p].X, axis = 0)\n",
    "\n",
    "        non_zero = np.where(np.array(X)[0] != 0)[0]\n",
    "        zero = np.where(np.array(X)[0] == 0)[0]\n",
    "        true_zeros = np.intersect1d(zero, np.where(np.array(ctrl)[0] == 0)[0])\n",
    "        non_dropouts = np.concatenate((non_zero, true_zeros))\n",
    "\n",
    "        top = adata.uns['rank_genes_groups_cov_all'][pert]\n",
    "        gene_idx_top = [gene_id2idx[i] for i in top]\n",
    "\n",
    "        non_dropout_20 = [i for i in gene_idx_top if i in non_dropouts][:20]\n",
    "        non_dropout_20_gene_id = [gene_idx2id[i] for i in non_dropout_20]\n",
    "\n",
    "        non_zero_20 = [i for i in gene_idx_top if i in non_zero][:20]\n",
    "        non_zero_20_gene_id = [gene_idx2id[i] for i in non_zero_20]\n",
    "\n",
    "        non_zeros_gene_idx[pert] = np.sort(non_zero)\n",
    "        non_dropout_gene_idx[pert] = np.sort(non_dropouts)\n",
    "        top_non_dropout_de_20[pert] = np.array(non_dropout_20_gene_id)\n",
    "        top_non_zero_de_20[pert] = np.array(non_zero_20_gene_id)\n",
    "        \n",
    "    non_zero = np.where(np.array(X)[0] != 0)[0]\n",
    "    zero = np.where(np.array(X)[0] == 0)[0]\n",
    "    true_zeros = np.intersect1d(zero, np.where(np.array(ctrl)[0] == 0)[0])\n",
    "    non_dropouts = np.concatenate((non_zero, true_zeros))\n",
    "    \n",
    "    adata.uns['top_non_dropout_de_20'] = top_non_dropout_de_20\n",
    "    adata.uns['non_dropout_gene_idx'] = non_dropout_gene_idx\n",
    "    adata.uns['non_zeros_gene_idx'] = non_zeros_gene_idx\n",
    "    adata.uns['top_non_zero_de_20'] = top_non_zero_de_20\n",
    "    \n",
    "    return adata\n",
    "\n",
    "\n",
    "class DataSplitter():\n",
    "    \"\"\"\n",
    "    Class for handling data splitting. This class is able to generate new\n",
    "    data splits and assign them as a new attribute to the data file.\n",
    "    \"\"\"\n",
    "    def __init__(self, adata, split_type='single', seen=0):\n",
    "        self.adata = adata\n",
    "        self.split_type = split_type\n",
    "        self.seen = seen\n",
    "\n",
    "    def split_data(self, test_size=0.1, test_pert_genes=None,\n",
    "                   test_perts=None, split_name='split', seed=None, val_size = 0.1,\n",
    "                   train_gene_set_size = 0.75, combo_seen2_train_frac = 0.75, only_test_set_perts = False):\n",
    "        \"\"\"\n",
    "        Split dataset and adds split as a column to the dataframe\n",
    "        Note: split categories are train, val, test\n",
    "        \"\"\"\n",
    "        np.random.seed(seed=seed)\n",
    "        unique_perts = [p for p in self.adata.obs['condition'].unique() if\n",
    "                        p != 'ctrl']\n",
    "        \n",
    "        if self.split_type == 'simulation':\n",
    "            train, test, test_subgroup = self.get_simulation_split(unique_perts,\n",
    "                                                                  train_gene_set_size,\n",
    "                                                                  combo_seen2_train_frac, \n",
    "                                                                  seed, test_perts, only_test_set_perts)\n",
    "            train, val, val_subgroup = self.get_simulation_split(train,\n",
    "                                                                  0.9,\n",
    "                                                                  0.9,\n",
    "                                                                  seed)\n",
    "            ## adding back ctrl to train...\n",
    "            train.append('ctrl')\n",
    "        elif self.split_type == 'simulation_single':\n",
    "            train, test, test_subgroup = self.get_simulation_split_single(unique_perts,\n",
    "                                                                  train_gene_set_size,\n",
    "                                                                  seed, test_perts, only_test_set_perts)\n",
    "            train, val, val_subgroup = self.get_simulation_split_single(train,\n",
    "                                                                  0.9,\n",
    "                                                                  seed)\n",
    "        elif self.split_type == 'no_test':\n",
    "            train, val = self.get_split_list(unique_perts,\n",
    "                                          test_size=val_size)      \n",
    "        else:\n",
    "            train, test = self.get_split_list(unique_perts,\n",
    "                                          test_pert_genes=test_pert_genes,\n",
    "                                          test_perts=test_perts,\n",
    "                                          test_size=test_size)\n",
    "            \n",
    "            train, val = self.get_split_list(train, test_size=val_size)\n",
    "\n",
    "        map_dict = {x: 'train' for x in train}\n",
    "        map_dict.update({x: 'val' for x in val})\n",
    "        if self.split_type != 'no_test':\n",
    "            map_dict.update({x: 'test' for x in test})\n",
    "        map_dict.update({'ctrl': 'train'})\n",
    "\n",
    "        self.adata.obs[split_name] = self.adata.obs['condition'].map(map_dict)\n",
    "\n",
    "        if self.split_type == 'simulation':\n",
    "            return self.adata, {'test_subgroup': test_subgroup, \n",
    "                                'val_subgroup': val_subgroup\n",
    "                               }\n",
    "        else:\n",
    "            return self.adata\n",
    "    \n",
    "    def get_simulation_split_single(self, pert_list, train_gene_set_size = 0.85, seed = 1, test_set_perts = None, only_test_set_perts = False):\n",
    "        unique_pert_genes = self.get_genes_from_perts(pert_list)\n",
    "        \n",
    "        pert_train = []\n",
    "        pert_test = []\n",
    "        np.random.seed(seed=seed)\n",
    "        \n",
    "        if only_test_set_perts and (test_set_perts is not None):\n",
    "            ood_genes = np.array(test_set_perts)\n",
    "            train_gene_candidates = np.setdiff1d(unique_pert_genes, ood_genes)\n",
    "        else:\n",
    "            ## a pre-specified list of genes\n",
    "            train_gene_candidates = np.random.choice(unique_pert_genes,\n",
    "                                                    int(len(unique_pert_genes) * train_gene_set_size), replace = False)\n",
    "\n",
    "            if test_set_perts is not None:\n",
    "                num_overlap = len(np.intersect1d(train_gene_candidates, test_set_perts))\n",
    "                train_gene_candidates = train_gene_candidates[~np.isin(train_gene_candidates, test_set_perts)]\n",
    "                ood_genes_exclude_test_set = np.setdiff1d(unique_pert_genes, np.union1d(train_gene_candidates, test_set_perts))\n",
    "                train_set_addition = np.random.choice(ood_genes_exclude_test_set, num_overlap, replace = False)\n",
    "                train_gene_candidates = np.concatenate((train_gene_candidates, train_set_addition))\n",
    "                \n",
    "            ## ood genes\n",
    "            ood_genes = np.setdiff1d(unique_pert_genes, train_gene_candidates)  \n",
    "        \n",
    "        pert_single_train = self.get_perts_from_genes(train_gene_candidates, pert_list,'single')\n",
    "        unseen_single = self.get_perts_from_genes(ood_genes, pert_list, 'single')\n",
    "        assert len(unseen_single) + len(pert_single_train) == len(pert_list)\n",
    "        \n",
    "        return pert_single_train, unseen_single, {'unseen_single': unseen_single}\n",
    "    \n",
    "    def get_simulation_split(self, pert_list, train_gene_set_size = 0.85, combo_seen2_train_frac = 0.85, seed = 1, test_set_perts = None, only_test_set_perts = False):\n",
    "        \n",
    "        unique_pert_genes = self.get_genes_from_perts(pert_list)\n",
    "        \n",
    "        pert_train = []\n",
    "        pert_test = []\n",
    "        np.random.seed(seed=seed)\n",
    "        \n",
    "        if only_test_set_perts and (test_set_perts is not None):\n",
    "            ood_genes = np.array(test_set_perts)\n",
    "            train_gene_candidates = np.setdiff1d(unique_pert_genes, ood_genes)\n",
    "        else:\n",
    "            ## a pre-specified list of genes\n",
    "            train_gene_candidates = np.random.choice(unique_pert_genes,\n",
    "                                                    int(len(unique_pert_genes) * train_gene_set_size), replace = False)\n",
    "\n",
    "            if test_set_perts is not None:\n",
    "                num_overlap = len(np.intersect1d(train_gene_candidates, test_set_perts))\n",
    "                train_gene_candidates = train_gene_candidates[~np.isin(train_gene_candidates, test_set_perts)]\n",
    "                ood_genes_exclude_test_set = np.setdiff1d(unique_pert_genes, np.union1d(train_gene_candidates, test_set_perts))\n",
    "                train_set_addition = np.random.choice(ood_genes_exclude_test_set, num_overlap, replace = False)\n",
    "                train_gene_candidates = np.concatenate((train_gene_candidates, train_set_addition))\n",
    "                \n",
    "            ## ood genes\n",
    "            ood_genes = np.setdiff1d(unique_pert_genes, train_gene_candidates)                \n",
    "        \n",
    "        pert_single_train = self.get_perts_from_genes(train_gene_candidates, pert_list,'single')\n",
    "        pert_combo = self.get_perts_from_genes(train_gene_candidates, pert_list,'combo')\n",
    "        pert_train.extend(pert_single_train)\n",
    "        \n",
    "        ## the combo set with one of them in OOD\n",
    "        combo_seen1 = [x for x in pert_combo if len([t for t in x.split('+') if\n",
    "                                     t in train_gene_candidates]) == 1]\n",
    "        pert_test.extend(combo_seen1)\n",
    "        \n",
    "        pert_combo = np.setdiff1d(pert_combo, combo_seen1)\n",
    "        ## randomly sample the combo seen 2 as a test set, the rest in training set\n",
    "        np.random.seed(seed=seed)\n",
    "        pert_combo_train = np.random.choice(pert_combo, int(len(pert_combo) * combo_seen2_train_frac), replace = False)\n",
    "       \n",
    "        combo_seen2 = np.setdiff1d(pert_combo, pert_combo_train).tolist()\n",
    "        pert_test.extend(combo_seen2)\n",
    "        pert_train.extend(pert_combo_train)\n",
    "        \n",
    "        ## unseen single\n",
    "        unseen_single = self.get_perts_from_genes(ood_genes, pert_list, 'single')\n",
    "        combo_ood = self.get_perts_from_genes(ood_genes, pert_list, 'combo')\n",
    "        pert_test.extend(unseen_single)\n",
    "        \n",
    "        ## here only keeps the seen 0, since seen 1 is tackled above\n",
    "        combo_seen0 = [x for x in combo_ood if len([t for t in x.split('+') if\n",
    "                                     t in train_gene_candidates]) == 0]\n",
    "        pert_test.extend(combo_seen0)\n",
    "        assert len(combo_seen1) + len(combo_seen0) + len(unseen_single) + len(pert_train) + len(combo_seen2) == len(pert_list)\n",
    "\n",
    "        return pert_train, pert_test, {'combo_seen0': combo_seen0,\n",
    "                                       'combo_seen1': combo_seen1,\n",
    "                                       'combo_seen2': combo_seen2,\n",
    "                                       'unseen_single': unseen_single}\n",
    "        \n",
    "    def get_split_list(self, pert_list, test_size=0.1,\n",
    "                       test_pert_genes=None, test_perts=None,\n",
    "                       hold_outs=True):\n",
    "        \"\"\"\n",
    "        Splits a given perturbation list into train and test with no shared\n",
    "        perturbations\n",
    "        \"\"\"\n",
    "\n",
    "        single_perts = [p for p in pert_list if 'ctrl' in p and p != 'ctrl']\n",
    "        combo_perts = [p for p in pert_list if 'ctrl' not in p]\n",
    "        unique_pert_genes = self.get_genes_from_perts(pert_list)\n",
    "        hold_out = []\n",
    "\n",
    "        if test_pert_genes is None:\n",
    "            test_pert_genes = np.random.choice(unique_pert_genes,\n",
    "                                        int(len(single_perts) * test_size))\n",
    "\n",
    "        # Only single unseen genes (in test set)\n",
    "        # Train contains both single and combos\n",
    "        if self.split_type == 'single' or self.split_type == 'single_only':\n",
    "            test_perts = self.get_perts_from_genes(test_pert_genes, pert_list,\n",
    "                                                   'single')\n",
    "            if self.split_type == 'single_only':\n",
    "                # Discard all combos\n",
    "                hold_out = combo_perts\n",
    "            else:\n",
    "                # Discard only those combos which contain test genes\n",
    "                hold_out = self.get_perts_from_genes(test_pert_genes, pert_list,\n",
    "                                                     'combo')\n",
    "        \n",
    "        elif self.split_type == 'no_test':\n",
    "            if test_perts is None:\n",
    "                test_perts = np.random.choice(pert_list,\n",
    "                                    int(len(pert_list) * test_size))\n",
    "            \n",
    "\n",
    "        elif self.split_type == 'combo':\n",
    "            if self.seen == 0:\n",
    "                # NOTE: This can reduce the dataset size!\n",
    "                # To prevent this set 'holdouts' to False, this will cause\n",
    "                # the test set to have some perturbations with 1 gene seen\n",
    "                single_perts = self.get_perts_from_genes(test_pert_genes,\n",
    "                                                         pert_list, 'single')\n",
    "                combo_perts = self.get_perts_from_genes(test_pert_genes,\n",
    "                                                        pert_list, 'combo')\n",
    "\n",
    "                if hold_outs:\n",
    "                    # This just checks that none of the combos have 2 seen genes\n",
    "                    hold_out = [t for t in combo_perts if\n",
    "                                len([t for t in t.split('+') if\n",
    "                                     t not in test_pert_genes]) > 0]\n",
    "                combo_perts = [c for c in combo_perts if c not in hold_out]\n",
    "                test_perts = single_perts + combo_perts\n",
    "\n",
    "            elif self.seen == 1:\n",
    "                # NOTE: This can reduce the dataset size!\n",
    "                # To prevent this set 'holdouts' to False, this will cause\n",
    "                # the test set to have some perturbations with 2 genes seen\n",
    "                single_perts = self.get_perts_from_genes(test_pert_genes,\n",
    "                                                         pert_list, 'single')\n",
    "                combo_perts = self.get_perts_from_genes(test_pert_genes,\n",
    "                                                        pert_list, 'combo')\n",
    "\n",
    "                if hold_outs:\n",
    "                    # This just checks that none of the combos have 2 seen genes\n",
    "                    hold_out = [t for t in combo_perts if\n",
    "                                len([t for t in t.split('+') if\n",
    "                                     t not in test_pert_genes]) > 1]\n",
    "                combo_perts = [c for c in combo_perts if c not in hold_out]\n",
    "                test_perts = single_perts + combo_perts\n",
    "\n",
    "            elif self.seen == 2:\n",
    "                if test_perts is None:\n",
    "                    test_perts = np.random.choice(combo_perts,\n",
    "                                     int(len(combo_perts) * test_size))       \n",
    "                else:\n",
    "                    test_perts = np.array(test_perts)\n",
    "        else:\n",
    "            if test_perts is None:\n",
    "                test_perts = np.random.choice(combo_perts,\n",
    "                                    int(len(combo_perts) * test_size))\n",
    "        \n",
    "        train_perts = [p for p in pert_list if (p not in test_perts)\n",
    "                                        and (p not in hold_out)]\n",
    "        return train_perts, test_perts\n",
    "\n",
    "    def get_perts_from_genes(self, genes, pert_list, type_='both'):\n",
    "        \"\"\"\n",
    "        Returns all single/combo/both perturbations that include a gene\n",
    "        \"\"\"\n",
    "\n",
    "        single_perts = [p for p in pert_list if ('ctrl' in p) and (p != 'ctrl')]\n",
    "        combo_perts = [p for p in pert_list if 'ctrl' not in p]\n",
    "        \n",
    "        perts = []\n",
    "        \n",
    "        if type_ == 'single':\n",
    "            pert_candidate_list = single_perts\n",
    "        elif type_ == 'combo':\n",
    "            pert_candidate_list = combo_perts\n",
    "        elif type_ == 'both':\n",
    "            pert_candidate_list = pert_list\n",
    "            \n",
    "        for p in pert_candidate_list:\n",
    "            for g in genes:\n",
    "                if g in parse_any_pert(p):\n",
    "                    perts.append(p)\n",
    "                    break\n",
    "        return perts\n",
    "\n",
    "    def get_genes_from_perts(self, perts):\n",
    "        \"\"\"\n",
    "        Returns list of genes involved in a given perturbation list\n",
    "        \"\"\"\n",
    "\n",
    "        if type(perts) is str:\n",
    "            perts = [perts]\n",
    "        gene_list = [p.split('+') for p in np.unique(perts)]\n",
    "        gene_list = [item for sublist in gene_list for item in sublist]\n",
    "        gene_list = [g for g in gene_list if g != 'ctrl']\n",
    "        return np.unique(gene_list)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
